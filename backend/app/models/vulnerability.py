from app import db
from datetime import datetime
import enum
import json

class Severity(enum.Enum):
    LOW = "Low"
    MEDIUM = "Medium"
    HIGH = "High"
    CRITICAL = "Critical"

class Status(enum.Enum):
    OPEN = "Open"
    MITIGATING = "Mitigating"
    FIXED = "Fixed"
    ACCEPTED = "Accepted"

class Source(enum.Enum):
    INTERNAL = "internal"
    NVD = "nvd"
    EXTERNAL = "external"

class Vulnerability(db.Model):
    __tablename__ = 'vulns'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    cve_id = db.Column(db.String(20), unique=True)
    description = db.Column(db.Text)
    vector = db.Column(db.String(100))  # CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H
    base_score = db.Column(db.Float)
    severity = db.Column(db.Enum(Severity), nullable=False)
    status = db.Column(db.Enum(Status), default=Status.OPEN, nullable=False)
    source = db.Column(db.Enum(Source), default=Source.INTERNAL, nullable=False)
    owner_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    evaluations = db.relationship('Evaluation', backref='vulnerability', lazy='dynamic', cascade='all, delete-orphan')
    
    def __init__(self, title, severity, owner_id, cve_id=None, description=None, 
                 vector=None, base_score=None, status=Status.OPEN, source=Source.INTERNAL):
        self.title = title
        self.severity = severity
        self.owner_id = owner_id
        self.cve_id = cve_id
        self.description = description
        self.vector = vector
        self.base_score = base_score
        self.status = status
        self.source = source
    
    def calculate_base_score(self):
        """Calculate CVSS Base Score from vector"""
        if not self.vector:
            return None
        
        # Parse CVSS vector
        try:
            metrics = self._parse_cvss_vector(self.vector)
            score = self._calculate_score(metrics)
            self.base_score = score
            self.severity = self._get_severity(score)
            return score
        except Exception as e:
            print(f"Error calculating CVSS score: {e}")
            return None
    
    def _parse_cvss_vector(self, vector):
        """Parse CVSS vector string into metrics dictionary"""
        if not vector.startswith('CVSS:3.1/'):
            raise ValueError("Invalid CVSS vector format")
        
        metrics = {}
        parts = vector.replace('CVSS:3.1/', '').split('/')
        
        for part in parts:
            if ':' in part:
                key, value = part.split(':')
                metrics[key] = value
        
        return metrics
    
    def _calculate_score(self, metrics):
        """Calculate CVSS Base Score from metrics"""
        # Simplified CVSS v3.1 calculation
        # This is a basic implementation - for production, use a proper CVSS library
        
        # Base metrics scoring
        av_scores = {'N': 0.85, 'A': 0.62, 'L': 0.55, 'P': 0.2}
        ac_scores = {'L': 0.77, 'H': 0.44}
        pr_scores = {'N': 0.85, 'L': 0.62, 'H': 0.27}
        ui_scores = {'N': 0.85, 'R': 0.62}
        scope_scores = {'U': 6.42, 'C': 7.52}
        
        # Impact scoring
        c_scores = {'N': 0, 'L': 0.22, 'H': 0.56}
        i_scores = {'N': 0, 'L': 0.22, 'H': 0.56}
        a_scores = {'N': 0, 'L': 0.22, 'H': 0.56}
        
        # Get values from metrics
        av = metrics.get('AV', 'N')
        ac = metrics.get('AC', 'L')
        pr = metrics.get('PR', 'N')
        ui = metrics.get('UI', 'N')
        s = metrics.get('S', 'U')
        c = metrics.get('C', 'N')
        i = metrics.get('I', 'N')
        a = metrics.get('A', 'N')
        
        # Calculate Exploitability
        exploitability = 8.22 * av_scores[av] * ac_scores[ac] * pr_scores[pr] * ui_scores[ui]
        
        # Calculate Impact
        impact = 1 - ((1 - c_scores[c]) * (1 - i_scores[i]) * (1 - a_scores[a]))
        
        # Calculate Base Score
        if impact <= 0:
            base_score = 0
        elif s == 'U':  # Unchanged scope
            base_score = min(10, impact + exploitability)
        else:  # Changed scope
            base_score = min(10, 1.08 * (impact + exploitability))
        
        return round(base_score, 1)
    
    def _get_severity(self, score):
        """Get severity level from score"""
        if score >= 9.0:
            return Severity.CRITICAL
        elif score >= 7.0:
            return Severity.HIGH
        elif score >= 4.0:
            return Severity.MEDIUM
        else:
            return Severity.LOW
    
    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'cve_id': self.cve_id,
            'description': self.description,
            'vector': self.vector,
            'base_score': self.base_score,
            'severity': self.severity.value if self.severity else None,
            'status': self.status.value if self.status else None,
            'source': self.source.value if self.source else None,
            'owner_id': self.owner_id,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        }
    
    def __repr__(self):
        return f'<Vulnerability {self.title}>'

