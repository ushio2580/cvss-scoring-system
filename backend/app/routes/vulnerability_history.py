from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from app import db
from app.models.vulnerability_history import VulnerabilityHistory
from app.models.vulnerability import Vulnerability
from app.models.user import User
from app.utils.authorization import admin_required, analyst_required
from sqlalchemy import desc
from datetime import datetime, timedelta

history_bp = Blueprint('vulnerability_history', __name__)

@history_bp.route('/vulnerability/<int:vuln_id>/history', methods=['GET'])
@jwt_required()
@analyst_required
def get_vulnerability_history(vuln_id):
    """Get history for a specific vulnerability"""
    current_user_id = get_jwt_identity()
    
    # Get query parameters
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 50, type=int)
    action = request.args.get('action')
    field_name = request.args.get('field_name')
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    
    # Verify vulnerability exists
    vulnerability = Vulnerability.query.get(vuln_id)
    if not vulnerability:
        return jsonify({'error': 'Vulnerability not found'}), 404
    
    # Build query
    query = VulnerabilityHistory.query.filter_by(vulnerability_id=vuln_id)
    
    # Apply filters
    if action:
        query = query.filter(VulnerabilityHistory.action == action)
    
    if field_name:
        query = query.filter(VulnerabilityHistory.field_name == field_name)
    
    if start_date:
        try:
            start_datetime = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
            query = query.filter(VulnerabilityHistory.timestamp >= start_datetime)
        except ValueError:
            pass
    
    if end_date:
        try:
            end_datetime = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
            query = query.filter(VulnerabilityHistory.timestamp <= end_datetime)
        except ValueError:
            pass
    
    # Order by timestamp (newest first)
    query = query.order_by(desc(VulnerabilityHistory.timestamp))
    
    # Paginate
    pagination = query.paginate(
        page=page, 
        per_page=per_page, 
        error_out=False
    )
    
    history = [entry.to_dict() for entry in pagination.items]
    
    return jsonify({
        'vulnerability': vulnerability.to_dict(),
        'history': history,
        'pagination': {
            'page': page,
            'per_page': per_page,
            'total': pagination.total,
            'pages': pagination.pages,
            'has_next': pagination.has_next,
            'has_prev': pagination.has_prev
        }
    }), 200

@history_bp.route('/vulnerability/<int:vuln_id>/history/summary', methods=['GET'])
@jwt_required()
@analyst_required
def get_vulnerability_history_summary(vuln_id):
    """Get summary statistics for vulnerability history"""
    current_user_id = get_jwt_identity()
    
    # Verify vulnerability exists
    vulnerability = Vulnerability.query.get(vuln_id)
    if not vulnerability:
        return jsonify({'error': 'Vulnerability not found'}), 404
    
    # Get date range (default: last 30 days)
    days = request.args.get('days', 30, type=int)
    end_date = datetime.utcnow()
    start_date = end_date - timedelta(days=days)
    
    # Get history in date range
    history = VulnerabilityHistory.query.filter(
        VulnerabilityHistory.vulnerability_id == vuln_id,
        VulnerabilityHistory.timestamp >= start_date,
        VulnerabilityHistory.timestamp <= end_date
    ).all()
    
    # Calculate statistics
    total_changes = len(history)
    actions_count = {}
    fields_count = {}
    users_count = {}
    
    for entry in history:
        # Count actions
        actions_count[entry.action] = actions_count.get(entry.action, 0) + 1
        
        # Count fields
        if entry.field_name:
            fields_count[entry.field_name] = fields_count.get(entry.field_name, 0) + 1
        
        # Count users
        users_count[entry.username] = users_count.get(entry.username, 0) + 1
    
    # Get top changes
    top_actions = sorted(actions_count.items(), key=lambda x: x[1], reverse=True)[:5]
    top_fields = sorted(fields_count.items(), key=lambda x: x[1], reverse=True)[:5]
    top_users = sorted(users_count.items(), key=lambda x: x[1], reverse=True)[:5]
    
    return jsonify({
        'vulnerability': vulnerability.to_dict(),
        'period': {
            'start_date': start_date.isoformat(),
            'end_date': end_date.isoformat(),
            'days': days
        },
        'statistics': {
            'total_changes': total_changes,
            'unique_actions': len(actions_count),
            'unique_fields': len(fields_count),
            'unique_users': len(users_count)
        },
        'top_actions': [{'action': action, 'count': count} for action, count in top_actions],
        'top_fields': [{'field': field, 'count': count} for field, count in top_fields],
        'top_users': [{'username': username, 'count': count} for username, count in top_users]
    }), 200

@history_bp.route('/vulnerability/<int:vuln_id>/history/export', methods=['GET'])
@jwt_required()
@analyst_required
def export_vulnerability_history(vuln_id):
    """Export vulnerability history to CSV"""
    current_user_id = get_jwt_identity()
    
    # Verify vulnerability exists
    vulnerability = Vulnerability.query.get(vuln_id)
    if not vulnerability:
        return jsonify({'error': 'Vulnerability not found'}), 404
    
    # Get all history for this vulnerability
    history = VulnerabilityHistory.query.filter_by(
        vulnerability_id=vuln_id
    ).order_by(desc(VulnerabilityHistory.timestamp)).all()
    
    # Create CSV
    import csv
    from io import StringIO
    
    output = StringIO()
    writer = csv.writer(output)
    
    # Write header
    writer.writerow([
        'ID', 'Timestamp', 'User', 'Action', 'Field Name', 
        'Old Value', 'New Value', 'IP Address'
    ])
    
    # Write data
    for entry in history:
        writer.writerow([
            entry.id,
            entry.timestamp.isoformat() if entry.timestamp else '',
            entry.username,
            entry.action,
            entry.field_name or '',
            entry.old_value or '',
            entry.new_value or '',
            entry.ip_address or ''
        ])
    
    output.seek(0)
    
    from flask import Response
    return Response(
        output.getvalue(),
        mimetype='text/csv',
        headers={'Content-Disposition': f'attachment; filename=vulnerability_{vuln_id}_history_{datetime.utcnow().strftime("%Y%m%d")}.csv'}
    )

@history_bp.route('/vulnerability/<int:vuln_id>/history/actions', methods=['GET'])
@jwt_required()
@analyst_required
def get_vulnerability_history_actions(vuln_id):
    """Get available filter options for vulnerability history"""
    current_user_id = get_jwt_identity()
    
    # Verify vulnerability exists
    vulnerability = Vulnerability.query.get(vuln_id)
    if not vulnerability:
        return jsonify({'error': 'Vulnerability not found'}), 404
    
    # Get distinct values
    actions = db.session.query(VulnerabilityHistory.action).filter_by(
        vulnerability_id=vuln_id
    ).distinct().all()
    
    field_names = db.session.query(VulnerabilityHistory.field_name).filter_by(
        vulnerability_id=vuln_id
    ).filter(VulnerabilityHistory.field_name.isnot(None)).distinct().all()
    
    usernames = db.session.query(VulnerabilityHistory.username).filter_by(
        vulnerability_id=vuln_id
    ).distinct().all()
    
    return jsonify({
        'actions': [action[0] for action in actions],
        'field_names': [field[0] for field in field_names],
        'usernames': [username[0] for username in usernames]
    }), 200
